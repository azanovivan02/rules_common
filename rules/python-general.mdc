---
description: "General Python and Software Engineering Standards"
globs: "**/*.py"
alwaysApply: false
---

# General Python & Software Engineering Standards

## Coding Standards

### CORE PHILOSOPHY: THE HYBRID ARCHITECTURE

1. **Macro OOP, Micro FP**:
    - Use **OOP** for architectural boundaries, service orchestration, and dependency injection.
    - Use **FP** (Pure Functions) for business logic, data transformation, and algorithmic cores.
2. **Imperative Shell, Functional Core**:
    - Push I/O (DB, API, Disk) to the edges of the system (Controllers/Repositories).
    - Keep the core logic pure, deterministic, and unit-testable without mocks.
3. **Composition Over Inheritance**:
    - Prefer `has-a` relationships. Avoid class inheritance deeper than 2 levels.
    - Use `typing.Protocol` for interfaces, not `abc.ABC`.

### PYTHON 3.14 MODERN STANDARDS

- **Strict Typing**: All functions must have type hints. Use `mypy` strict mode standards.
- **Modern Syntax**:
    - Use `type Alias = ...` for type aliases (PEP 695).
    - Use `|` for Unions (e.g., `str | None` instead of `Optional[str]`).
    - Use `match/case` for control flow over complex `if/elif` chains.
- **Async By Default**: Use `async/await` for all I/O bound operations (DB, Network).

### DATA STRUCTURES & MODELING

- **Immutability**:
    - Domain entities must be immutable.
    - Use `attrs.define(frozen=True)` for internal domain objects.
    - Use `pydantic.BaseModel` (frozen) for I/O boundaries.
- **Algebraic Data Types (ADTs)**:
    - Avoid throwing exceptions for expected business failures (e.g., UserNotFound).
    - Return Union Types (Sum Types) representing Success vs Failure.
    - Example: `def process() -> Success | Failure:`
- **No Anemic Models**:
    - Data objects should validatable constraints at construction.
    - However, keep heavy logic separate in pure functions.

### ML & DATA ENGINEERING PRACTICES

- **Vectorization**:
    - NEVER use explicit `for` loops for data processing.
    - Use `polars` (preferred) or `numpy` vectorization.
- **Pipeline Composition**:
    - Chain transformations using fluent APIs or functional pipes.
    - Avoid mutating DataFrames in place. Return new DataFrames.
- **Generators**:
    - Use generator expressions `(...)` for streaming data processing to save memory.
    - Only materialize to `list` or `polars.DataFrame` at the final step.

### CODE STYLE & LINTING

- **Formatting**: Adhere to `ruff` defaults.
- **Imports**:
    - No wildcard imports (`from module import *`).
    - Use absolute imports.
- **Naming**:
    - Variables: `snake_case` (descriptive, e.g., `user_id` not `x`).
    - Classes: `PascalCase`.
    - Constants: `UPPER_SNAKE_CASE`.
- **Path Handling**: Always use `pathlib.Path`, never `os.path`.

### "ANTI-PATTERNS" TO AVOID

- **Deep Inheritance**: Do not create generic "BaseHandler" classes.
- **God Objects**: No "Manager" or "Util" classes that do everything.
- **Primitive Obsession**: Do not pass raw dicts or tuples. Wrap them in Typed objects.
- **Point-Free Obsession**: Do not remove function arguments if it hurts readability.
- **Mutable Defaults**: Never use `def func(x=[])`.

### GENERAL STRUCTURE & BEST PRACTICES

- **Colocation**:
    - Put related functions, classes and variables into the same file if possible, maximize physical cohesion (needed for better Cursor IDE rag retrieval)
- **Class definition**:
    - Avoid writing `__init__` methods manually, use `dataclasses`.
- **Function structure**:
    - Prefer pure functions (but they may use temporary local state).
    - Decompose large functions into reasonably small subfunctions with clearly defined roles.
    - Avoid cases when local variables are used inside a small segment of a large function then hang uselessly inside
      the scope. Decompose into smaller functions so short-term variables are contained.
- **Order of declarations**:
    - Declare on top those methods which are imported by other files, then declare methods which are used in top
      methods (move from caller to callee, high-level to low-level).
- **Logic**:
    - Avoid statements like `if not X`; use `if X is not None` instead.
    - Avoid re-exporting classes from other modules; always import them directly from their original location.
    - When overriding a method in a subclass, explicitly mark the method with decorator `@override` from `typing`.

### EXAMPLES

#### Good: ADT with Match

```python
@dataclass(frozen=True)
class Success[T]:
    value: T

@dataclass(frozen=True)
class Error:
    message: str

def compute(x: int) -> Success[float] | Error:
    if x == 0: return Error("Div zero")
    return Success(10.0 / x)

match compute(0):
    case Success(val): print(val)
    case Error(msg): print(msg)
